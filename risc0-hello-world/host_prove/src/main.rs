// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{SQUARE_CHECK_GUEST_ELF, SQUARE_CHECK_GUEST_ID};
use risc0_zkvm::sha::Digest;
use risc0_zkvm::{default_prover, ExecutorEnv};

use std::{fs::File, io::Write, path::PathBuf};

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    env_logger::init();

    // An executor environment describes the configurations for the zkVM
    // including program inputs.
    let square: u32 = 1787569;
    let root: u32 = 1337;
    let env = ExecutorEnv::builder()
        .write(&square)
        .unwrap()
        .write(&root)
        .unwrap()
        .build()
        .unwrap();

    // Obtain default prover.
    let prover = default_prover();

    // Produce a receipt by proving the specified ELF binary.
    println!("Proving that we know square root of {}", square);
    let receipt = prover.prove_elf(env, SQUARE_CHECK_GUEST_ELF).unwrap();

    // Store receipt.
    let inner_bytes = bincode::serialize(&receipt.inner).unwrap();
    write_u8_bytes_to_file("./output/receipt_inner", &inner_bytes);

    // Serlialize journal - second half of receipt.
    let journal_bytes = bincode::serialize(&receipt.journal).unwrap();
    write_u8_bytes_to_file("./output/receipt_journal", &journal_bytes);

    let method_digest: Digest = SQUARE_CHECK_GUEST_ID.into();
    let method_bytes = bincode::serialize(&method_digest).unwrap();
    write_u8_bytes_to_file("./output/receipt_method", &method_bytes);
}

/// Writes a content to a file at the given path.
pub fn write_u8_bytes_to_file(path: &str, bytes: &[u8]) {
    let path = PathBuf::from(path);
    let mut file = File::create(path).unwrap();
    file.write_all(bytes).unwrap();
}
